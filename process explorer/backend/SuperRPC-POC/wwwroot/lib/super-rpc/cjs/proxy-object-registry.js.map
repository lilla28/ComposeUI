{"version":3,"file":"proxy-object-registry.js","sourceRoot":"","sources":["../../src/proxy-object-registry.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;;AAEU,QAAA,YAAY,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;AACtC,QAAA,eAAe,GAAG,MAAM,CAAC,aAAa,CAAC,CAAC;AAErD,MAAa,mBAAmB;IACX,QAAQ,GAAG,IAAI,GAAG,EAAwB,CAAC;IAC3C,eAAe,GAAG,IAAI,oBAAoB,CAAC,CAAC,WAAuB,EAAE,EAAE,CAAC,WAAW,EAAE,CAAC,CAAC;IAExG;;;OAGG;IACI,QAAQ,CAAC,KAAa,EAAE,GAAQ,EAAE,OAAoB;QACzD,MAAM,UAAU,GAAG,EAAE,CAAC;QACtB,GAAG,CAAC,oBAAY,CAAC,GAAG,KAAK,CAAC;QAC1B,GAAG,CAAC,uBAAe,CAAC,GAAG,GAAG,EAAE;YACxB,IAAI,CAAC,oBAAoB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;YAC7C,GAAG,CAAC,oBAAY,CAAC,GAAG,IAAI,CAAC;YACzB,OAAO,EAAE,EAAE,CAAC;QAChB,CAAC,CAAC;QACF,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,CAAC,uBAAe,CAAC,EAAE,UAAU,CAAC,CAAC;QACrE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;IAC/C,CAAC;IAEM,GAAG,CAAC,KAAa;QACpB,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAEM,MAAM,CAAC,KAAa;QACvB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAChC,CAAC;IAEM,GAAG,CAAC,KAAa;QACpB,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,CAAC;IAC7C,CAAC;IAEO,oBAAoB,CAAC,KAAa,EAAE,SAAiB;QACzD,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QAC3C,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAChC,CAAC;CAEJ;AArCD,kDAqCC","sourcesContent":["/**\r\n * Stores proxy objects/functions that represent remote objects - **used internally**.\r\n *\r\n * On the other side the corresponding \"host\" object/function is held in a registry by a strong reference,\r\n * and in order to be able to remove it and not leak the reference, we need a way to inform the other side\r\n * when the proxy object is \"no longer used\". For this we use the WeakRef and FinalizationRegistry features.\r\n *\r\n * We hold the proxy object/function with a weak reference, and when it is garbage collected, we can be sure that\r\n * it will not be used (called) anymore, so we remove it from our object registry and send a message\r\n * to the other side to remove the corresponding local object from the hostObjectRegistry as well.\r\n * @module\r\n * @internal\r\n */\r\n\r\nexport const rpc_disposed = Symbol('rpc_disposed');\r\nexport const rpc_disposeFunc = Symbol('rpc_dispose');\r\n\r\nexport class ProxyObjectRegistry {\r\n    private readonly registry = new Map<string, WeakRef<any>>();\r\n    private readonly objectFinalized = new FinalizationRegistry((rpc_dispose: () => void) => rpc_dispose());\r\n\r\n    /**\r\n     * Register an object.\r\n     * @param dispose Called when the object is removed from the registry (either explicitly or by the GC)\r\n     */\r\n    public register(objId: string, obj: any, dispose?: () => void) {\r\n        const unregToken = {};\r\n        obj[rpc_disposed] = false;\r\n        obj[rpc_disposeFunc] = () => {\r\n            this.remoteObjectDisposed(objId, unregToken);\r\n            obj[rpc_disposed] = true;\r\n            dispose?.();\r\n        };\r\n        this.objectFinalized.register(obj, obj[rpc_disposeFunc], unregToken);\r\n        this.registry.set(objId, new WeakRef(obj));\r\n    }\r\n\r\n    public has(objId: string) {\r\n        return this.registry.has(objId);\r\n    }\r\n\r\n    public delete(objId: string) {\r\n        this.registry.delete(objId);\r\n    }\r\n\r\n    public get(objId: string) {\r\n        return this.registry.get(objId)?.deref();\r\n    }\r\n\r\n    private remoteObjectDisposed(objId: string, uregToken: object) {\r\n        this.objectFinalized.unregister(uregToken);\r\n        this.registry.delete(objId);\r\n    }\r\n\r\n}"]}