{"version":3,"file":"rpc-descriptor-types.js","sourceRoot":"","sources":["../../src/rpc-descriptor-types.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;;AAwIH,iBAAiB;AACjB,SAAgB,WAAW,CAAC,UAAsC;IAC9D,OAAO,OAAO,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,IAAI,EAAE,CAAC;AAC/E,CAAC;AAFD,kCAEC;AAED,SAAgB,qBAAqB,CAAC,UAA8B,EAAE,GAAY;IAC9E,OAAO,OAAO,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,IAAI,IAAI,IAAI,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;AAC9H,CAAC;AAFD,sDAEC;AAED,SAAgB,qBAAqB,CAAC,UAA4B,EAAE,QAAgB;IAChF,OAA2B,UAAU,EAAE,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC;AACvH,CAAC;AAFD,sDAEC;AAED,SAAgB,qBAAqB,CAAC,UAA6B,EAAE,QAAiB;IAClF,OAA2B,UAAU,EAAE,iBAAiB,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC;AAC/H,CAAC;AAFD,sDAEC;AAED,SAAgB,oBAAoB,CAAC,UAAuB;IACxD,OAAO,UAAU,EAAE,IAAI,KAAK,UAAU,CAAC;AAC3C,CAAC;AAFD,oDAEC;AAKD,SAAgB,yBAAyB,CAAC,UAAqC,EAAE,IAAiB;IAC9F,IAAI,OAAO,UAAU,KAAK,QAAQ;QAAE,UAAU,GAAG,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC;IACxF,UAAU,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC;IACpC,UAAU,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;IAClC,UAAU,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC;IAC9B,OAAO,UAAU,CAAC;AACtB,CAAC;AAND,8DAMC;AAED,SAAgB,uBAAuB,CAAC,UAA4B,EAAE,GAAQ;IAC1E,UAAU,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC;IAElC,IAAI,GAAG,IAAI,UAAU,CAAC,SAAS,EAAE;QAC7B,KAAK,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,IAAI,UAAU,CAAC,SAAS,CAAC,OAAO,EAAE,EAAE;YACxD,UAAU,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,yBAAyB,CAAC,MAAM,EAAE,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;SAC3F;KACJ;IAED,OAAO,UAAU,CAAC;AACtB,CAAC;AAVD,0DAUC","sourcesContent":["/**\r\n * The descriptors are used to describe what properties/functions to expose on an object\r\n * and what are the function return behaviors.\r\n * @module\r\n */\r\n\r\n/**\r\n * Function return behaviors are the following:\r\n * - sync  - the proxy function will return the result synchronously (works only if the channel supports synchronous communication)\r\n * - async - the proxy function will return a Promise (works only if the channel supports asynchronous communication)\r\n * - void  - the return value is ignored and no result message is sent\r\n *\r\n * @see [[RPCChannel]]\r\n */\r\nexport type FunctionReturnBehavior = 'sync' | 'async' | 'void';\r\n\r\n/**\r\n * Describes a function, its arguments and its return type.\r\n */\r\nexport interface FunctionDescriptor<TReturn extends FunctionReturnBehavior = FunctionReturnBehavior> {\r\n    type?: 'function';\r\n    name?: string;\r\n\r\n    argCount?: number;\r\n\r\n    /**\r\n     * Describes the arguments of the function.\r\n     *\r\n     * Currently only functions need to be described with a [[FunctionDescriptor]], otherwise no descriptor is needed.\r\n     */\r\n    arguments?: ArgumentDescriptor[];\r\n\r\n    /**\r\n     * Return behavior.\r\n     */\r\n    returns?: TReturn;\r\n}\r\n\r\n/**\r\n * Describes a property.\r\n */\r\nexport interface PropertyDescriptor {\r\n    type?: 'property';\r\n    name: string;\r\n\r\n    /**\r\n     * The getter of the property.\r\n     * If set to 'async' then it returns a Promise.\r\n     * Default return behavior is 'sync'.\r\n     */\r\n    get?: FunctionDescriptor<'sync' | 'async'>;\r\n\r\n    /**\r\n     * The setter of the property.\r\n     * Default return behavior is 'sync'.\r\n     */\r\n    set?: FunctionDescriptor<'void' | 'sync'>;\r\n\r\n    /**\r\n     * If `true` then no setter will be generated for the proxy property.\r\n     * @default false\r\n     */\r\n    readonly?: boolean;\r\n}\r\n\r\n/**\r\n * Describes an argument for a function. If `idx` is not set then this\r\n * descriptor applies to *all* arguments.\r\n *\r\n * Since we only care about functions as arguments, for now, it is basically a FunctionDescriptor.\r\n * If the argument is not a function, do not specify a descriptor for it!\r\n */\r\nexport interface ArgumentDescriptor extends FunctionDescriptor {\r\n    idx?: number;\r\n}\r\n\r\n/**\r\n * Describes an object that we want to expose.\r\n */\r\nexport interface ObjectDescriptor {\r\n    type?: 'object';\r\n\r\n    /**\r\n     * List of functions we want to expose on the proxy object.\r\n     * Default return behavior is 'async'.\r\n     */\r\n    functions?: (string|FunctionDescriptor)[];\r\n\r\n    /**\r\n     * List of properties we want to expose on the proxy object.\r\n     */\r\n    proxiedProperties?: (string|PropertyDescriptor)[];\r\n\r\n    /**\r\n     * Since readonly property values don't change, they are sent to the other side, instead of generating a getter.\r\n     */\r\n    readonlyProperties?: string[];\r\n}\r\n\r\nexport interface ObjectDescriptorWithProps extends ObjectDescriptor {\r\n    /**\r\n     * This is filled in by the library. It contains the values of the readonlyProperties on the given object.\r\n     */\r\n    props?: any;\r\n}\r\n\r\n/**\r\n * Describes a class to expose.\r\n */\r\nexport interface ClassDescriptor {\r\n    type?: 'class';\r\n\r\n    /**\r\n     * Ignore this. Filled in by [[registerHostClass]] function.\r\n     */\r\n    classId?: string;\r\n\r\n    /**\r\n     * Expose a constructor function that will construct an instance on the host side.\r\n     * Default return behavior is 'sync'.\r\n     */\r\n    ctor?: FunctionDescriptor;\r\n\r\n    /**\r\n     * Describes the \"static\" part of the class, treated as an object.\r\n     */\r\n    static?: ObjectDescriptor;\r\n\r\n    /**\r\n     * Describes instances of this class.\r\n     */\r\n    instance?: ObjectDescriptor;\r\n}\r\n\r\nexport type Descriptor = ObjectDescriptor | FunctionDescriptor | PropertyDescriptor;\r\n\r\nexport type ObjectDescriptors = { [key: string]: ObjectDescriptorWithProps };\r\nexport type FunctionDescriptors = { [key: string]: FunctionDescriptor };\r\nexport type ClassDescriptors = { [key: string]: ClassDescriptor };\r\n\r\n// util functions\r\nexport function getPropName(descriptor: string | { name?: string }) {\r\n    return typeof descriptor === 'string' ? descriptor : descriptor.name || '';\r\n}\r\n\r\nexport function getArgumentDescriptor(descriptor: FunctionDescriptor, idx?: number) {\r\n    return typeof descriptor === 'object' ? descriptor.arguments?.find(arg => arg.idx == null || arg.idx === idx) : undefined;\r\n}\r\n\r\nexport function getFunctionDescriptor(descriptor: ObjectDescriptor, funcName: string) {\r\n    return <FunctionDescriptor>descriptor?.functions?.find(func => typeof func === 'object' && func.name === funcName);\r\n}\r\n\r\nexport function getPropertyDescriptor(descriptor?: ObjectDescriptor, propName?: string) {\r\n    return <PropertyDescriptor>descriptor?.proxiedProperties?.find(prop => typeof prop === 'object' && prop.name === propName);\r\n}\r\n\r\nexport function isFunctionDescriptor(descriptor?: Descriptor): descriptor is FunctionDescriptor {\r\n    return descriptor?.type === 'function';\r\n}\r\n\r\nexport type AnyConstructor = new (...args: any[]) => any;\r\nexport type AnyFunction = ((...args: any[]) => any);\r\n\r\nexport function processFunctionDescriptor(descriptor: string|FunctionDescriptor, func: AnyFunction) {\r\n    if (typeof descriptor === 'string') descriptor = { name: descriptor, type: 'function' };\r\n    descriptor ??= { type: 'function' };\r\n    descriptor.argCount = func.length;\r\n    descriptor.name ??= func.name;\r\n    return descriptor;\r\n}\r\n\r\nexport function processObjectDescriptor(descriptor: ObjectDescriptor, obj: any) {\r\n    descriptor ??= { type: 'object' };\r\n\r\n    if (obj && descriptor.functions) {\r\n        for (const [idx, fdescr] of descriptor.functions.entries()) {\r\n            descriptor.functions[idx] = processFunctionDescriptor(fdescr, obj[getPropName(fdescr)]);\r\n        }\r\n    }\r\n\r\n    return descriptor;\r\n}"]}