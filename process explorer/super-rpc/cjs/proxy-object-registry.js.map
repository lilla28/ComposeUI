{"version":3,"file":"proxy-object-registry.js","sourceRoot":"","sources":["../../src/proxy-object-registry.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;;AAEU,QAAA,YAAY,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;AACtC,QAAA,eAAe,GAAG,MAAM,CAAC,aAAa,CAAC,CAAC;AAErD,MAAa,mBAAmB;IACX,QAAQ,GAAG,IAAI,GAAG,EAAwB,CAAC;IAC3C,eAAe,GAAG,IAAI,oBAAoB,CAAC,CAAC,WAAuB,EAAE,EAAE,CAAC,WAAW,EAAE,CAAC,CAAC;IAExG;;;OAGG;IACI,QAAQ,CAAC,KAAa,EAAE,GAAQ,EAAE,OAAoB;QACzD,MAAM,UAAU,GAAG,EAAE,CAAC;QACtB,GAAG,CAAC,oBAAY,CAAC,GAAG,KAAK,CAAC;QAC1B,GAAG,CAAC,uBAAe,CAAC,GAAG,GAAG,EAAE;YACxB,IAAI,CAAC,oBAAoB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;YAC7C,GAAG,CAAC,oBAAY,CAAC,GAAG,IAAI,CAAC;YACzB,OAAO,EAAE,EAAE,CAAC;QAChB,CAAC,CAAC;QACF,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,CAAC,uBAAe,CAAC,EAAE,UAAU,CAAC,CAAC;QACrE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;IAC/C,CAAC;IAEM,GAAG,CAAC,KAAa;QACpB,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAEM,MAAM,CAAC,KAAa;QACvB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAChC,CAAC;IAEM,GAAG,CAAC,KAAa;QACpB,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,CAAC;IAC7C,CAAC;IAEO,oBAAoB,CAAC,KAAa,EAAE,SAAiB;QACzD,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QAC3C,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAChC,CAAC;CAEJ;AArCD,kDAqCC","sourcesContent":["/**\n * Stores proxy objects/functions that represent remote objects - **used internally**.\n *\n * On the other side the corresponding \"host\" object/function is held in a registry by a strong reference,\n * and in order to be able to remove it and not leak the reference, we need a way to inform the other side\n * when the proxy object is \"no longer used\". For this we use the WeakRef and FinalizationRegistry features.\n *\n * We hold the proxy object/function with a weak reference, and when it is garbage collected, we can be sure that\n * it will not be used (called) anymore, so we remove it from our object registry and send a message\n * to the other side to remove the corresponding local object from the hostObjectRegistry as well.\n * @module\n * @internal\n */\n\nexport const rpc_disposed = Symbol('rpc_disposed');\nexport const rpc_disposeFunc = Symbol('rpc_dispose');\n\nexport class ProxyObjectRegistry {\n    private readonly registry = new Map<string, WeakRef<any>>();\n    private readonly objectFinalized = new FinalizationRegistry((rpc_dispose: () => void) => rpc_dispose());\n\n    /**\n     * Register an object.\n     * @param dispose Called when the object is removed from the registry (either explicitly or by the GC)\n     */\n    public register(objId: string, obj: any, dispose?: () => void) {\n        const unregToken = {};\n        obj[rpc_disposed] = false;\n        obj[rpc_disposeFunc] = () => {\n            this.remoteObjectDisposed(objId, unregToken);\n            obj[rpc_disposed] = true;\n            dispose?.();\n        };\n        this.objectFinalized.register(obj, obj[rpc_disposeFunc], unregToken);\n        this.registry.set(objId, new WeakRef(obj));\n    }\n\n    public has(objId: string) {\n        return this.registry.has(objId);\n    }\n\n    public delete(objId: string) {\n        this.registry.delete(objId);\n    }\n\n    public get(objId: string) {\n        return this.registry.get(objId)?.deref();\n    }\n\n    private remoteObjectDisposed(objId: string, uregToken: object) {\n        this.objectFinalized.unregister(uregToken);\n        this.registry.delete(objId);\n    }\n\n}"]}