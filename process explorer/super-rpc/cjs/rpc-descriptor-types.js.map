{"version":3,"file":"rpc-descriptor-types.js","sourceRoot":"","sources":["../../src/rpc-descriptor-types.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;;AAqIH,iBAAiB;AACjB,SAAgB,WAAW,CAAC,UAAsC;IAC9D,OAAO,OAAO,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,IAAI,EAAE,CAAC;AAC/E,CAAC;AAFD,kCAEC;AAED,SAAgB,qBAAqB,CAAC,UAA8B,EAAE,GAAY;IAC9E,OAAO,OAAO,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC,UAAU,CAAC,SAAS,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,IAAI,IAAI,IAAI,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;AAC9H,CAAC;AAFD,sDAEC;AAED,SAAgB,qBAAqB,CAAC,UAA4B,EAAE,QAAgB;IAChF,OAA2B,UAAU,EAAE,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC;AACvH,CAAC;AAFD,sDAEC;AAED,SAAgB,qBAAqB,CAAC,UAA6B,EAAE,QAAiB;IAClF,OAA2B,UAAU,EAAE,iBAAiB,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,OAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC;AAC/H,CAAC;AAFD,sDAEC;AAED,SAAgB,oBAAoB,CAAC,UAAuB;IACxD,OAAO,UAAU,EAAE,IAAI,KAAK,UAAU,CAAC;AAC3C,CAAC;AAFD,oDAEC","sourcesContent":["/**\n * The descriptors are used to describe what properties/functions to expose on an object\n * and what are the function return behaviors.\n * @module\n */\n\n/**\n * Function return behaviors are the following:\n * - sync  - the proxy function will return the result synchronously (works only if the channel supports synchronous communication)\n * - async - the proxy function will return a Promise (works only if the channel supports asynchronous communication)\n * - void  - the return value is ignored and no result message is sent\n *\n * @see [[RPCChannel]]\n */\nexport type FunctionReturnBehavior = 'sync' | 'async' | 'void';\n\n/**\n * Describes a function, its arguments and its return type.\n */\nexport interface FunctionDescriptor<TReturn extends FunctionReturnBehavior = FunctionReturnBehavior> {\n    type?: 'function';\n    name?: string;\n\n    /**\n     * Describes the arguments of the function.\n     *\n     * Currently only functions need to be described with a [[FunctionDescriptor]], otherwise no descriptor is needed.\n     */\n    arguments?: ArgumentDescriptor[];\n\n    /**\n     * Return behavior.\n     */\n    returns?: TReturn;\n}\n\n/**\n * Describes a property.\n */\nexport interface PropertyDescriptor {\n    type?: 'property';\n    name: string;\n\n    /**\n     * The getter of the property.\n     * If set to 'async' then it returns a Promise.\n     * Default return behavior is 'sync'.\n     */\n    get?: FunctionDescriptor<'sync' | 'async'>;\n\n    /**\n     * The setter of the property.\n     * Default return behavior is 'sync'.\n     */\n    set?: FunctionDescriptor<'void' | 'sync'>;\n\n    /**\n     * If `true` then no setter will be generated for the proxy property.\n     * @default false\n     */\n    readonly?: boolean;\n}\n\n/**\n * Describes an argument for a function. If `idx` is not set then this\n * descriptor applies to *all* arguments.\n *\n * Since we only care about functions as arguments, for now, it is basically a FunctionDescriptor.\n * If the argument is not a function, do not specify a descriptor for it!\n */\nexport interface ArgumentDescriptor extends FunctionDescriptor {\n    idx?: number;\n}\n\n/**\n * Describes an object that we want to expose.\n */\nexport interface ObjectDescriptor {\n    type?: 'object';\n\n    /**\n     * List of functions we want to expose on the proxy object.\n     * Default return behavior is 'async'.\n     */\n    functions?: (string|FunctionDescriptor)[];\n\n    /**\n     * List of properties we want to expose on the proxy object.\n     */\n    proxiedProperties?: (string|PropertyDescriptor)[];\n\n    /**\n     * Since readonly property values don't change, they are sent to the other side, instead of generating a getter.\n     */\n    readonlyProperties?: string[];\n}\n\nexport interface ObjectDescriptorWithProps extends ObjectDescriptor {\n    /**\n     * This is filled in by the library. It contains the values of the readonlyProperties on the given object.\n     */\n    props?: any;\n}\n\n/**\n * Describes a class to expose.\n */\nexport interface ClassDescriptor {\n    type?: 'class';\n\n    /**\n     * Ignore this. Filled in by [[registerHostClass]] function.\n     */\n    classId?: string;\n\n    /**\n     * Expose a constructor function that will construct an instance on the host side.\n     * Default return behavior is 'sync'.\n     */\n    ctor?: FunctionDescriptor;\n\n    /**\n     * Describes the \"static\" part of the class, treated as an object.\n     */\n    static?: ObjectDescriptor;\n\n    /**\n     * Describes instances of this class.\n     */\n    instance?: ObjectDescriptor;\n}\n\nexport type Descriptor = ObjectDescriptor | FunctionDescriptor | PropertyDescriptor;\n\nexport type ObjectDescriptors = { [key: string]: ObjectDescriptorWithProps | FunctionDescriptor };\nexport type ClassDescriptors = { [key: string]: ClassDescriptor };\n\n// util functions\nexport function getPropName(descriptor: string | { name?: string }) {\n    return typeof descriptor === 'string' ? descriptor : descriptor.name || '';\n}\n\nexport function getArgumentDescriptor(descriptor: FunctionDescriptor, idx?: number) {\n    return typeof descriptor === 'object' ? descriptor.arguments?.find(arg => arg.idx == null || arg.idx === idx) : undefined;\n}\n\nexport function getFunctionDescriptor(descriptor: ObjectDescriptor, funcName: string) {\n    return <FunctionDescriptor>descriptor?.functions?.find(func => typeof func === 'object' && func.name === funcName);\n}\n\nexport function getPropertyDescriptor(descriptor?: ObjectDescriptor, propName?: string) {\n    return <PropertyDescriptor>descriptor?.proxiedProperties?.find(prop => typeof prop === 'object' && prop.name === propName);\n}\n\nexport function isFunctionDescriptor(descriptor?: Descriptor): descriptor is FunctionDescriptor {\n    return descriptor?.type === 'function';\n}"]}