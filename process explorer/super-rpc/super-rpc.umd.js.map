{"version":3,"file":"super-rpc.umd.js","sources":["../src/proxy-object-registry.ts","../src/rpc-descriptor-types.ts","../src/super-rpc.ts"],"sourcesContent":["/**\n * Stores proxy objects/functions that represent remote objects - **used internally**.\n *\n * On the other side the corresponding \"host\" object/function is held in a registry by a strong reference,\n * and in order to be able to remove it and not leak the reference, we need a way to inform the other side\n * when the proxy object is \"no longer used\". For this we use the WeakRef and FinalizationRegistry features.\n *\n * We hold the proxy object/function with a weak reference, and when it is garbage collected, we can be sure that\n * it will not be used (called) anymore, so we remove it from our object registry and send a message\n * to the other side to remove the corresponding local object from the hostObjectRegistry as well.\n * @module\n * @internal\n */\n\nexport const rpc_disposed = Symbol('rpc_disposed');\nexport const rpc_disposeFunc = Symbol('rpc_dispose');\n\nexport class ProxyObjectRegistry {\n    private readonly registry = new Map<string, WeakRef<any>>();\n    private readonly objectFinalized = new FinalizationRegistry((rpc_dispose: () => void) => rpc_dispose());\n\n    /**\n     * Register an object.\n     * @param dispose Called when the object is removed from the registry (either explicitly or by the GC)\n     */\n    public register(objId: string, obj: any, dispose?: () => void) {\n        const unregToken = {};\n        obj[rpc_disposed] = false;\n        obj[rpc_disposeFunc] = () => {\n            this.remoteObjectDisposed(objId, unregToken);\n            obj[rpc_disposed] = true;\n            dispose?.();\n        };\n        this.objectFinalized.register(obj, obj[rpc_disposeFunc], unregToken);\n        this.registry.set(objId, new WeakRef(obj));\n    }\n\n    public has(objId: string) {\n        return this.registry.has(objId);\n    }\n\n    public delete(objId: string) {\n        this.registry.delete(objId);\n    }\n\n    public get(objId: string) {\n        return this.registry.get(objId)?.deref();\n    }\n\n    private remoteObjectDisposed(objId: string, uregToken: object) {\n        this.objectFinalized.unregister(uregToken);\n        this.registry.delete(objId);\n    }\n\n}","/**\n * The descriptors are used to describe what properties/functions to expose on an object\n * and what are the function return behaviors.\n * @module\n */\n\n/**\n * Function return behaviors are the following:\n * - sync  - the proxy function will return the result synchronously (works only if the channel supports synchronous communication)\n * - async - the proxy function will return a Promise (works only if the channel supports asynchronous communication)\n * - void  - the return value is ignored and no result message is sent\n *\n * @see [[RPCChannel]]\n */\nexport type FunctionReturnBehavior = 'sync' | 'async' | 'void';\n\n/**\n * Describes a function, its arguments and its return type.\n */\nexport interface FunctionDescriptor<TReturn extends FunctionReturnBehavior = FunctionReturnBehavior> {\n    type?: 'function';\n    name?: string;\n\n    /**\n     * Describes the arguments of the function.\n     *\n     * Currently only functions need to be described with a [[FunctionDescriptor]], otherwise no descriptor is needed.\n     */\n    arguments?: ArgumentDescriptor[];\n\n    /**\n     * Return behavior.\n     */\n    returns?: TReturn;\n}\n\n/**\n * Describes a property.\n */\nexport interface PropertyDescriptor {\n    type?: 'property';\n    name: string;\n\n    /**\n     * The getter of the property.\n     * If set to 'async' then it returns a Promise.\n     * Default return behavior is 'sync'.\n     */\n    get?: FunctionDescriptor<'sync' | 'async'>;\n\n    /**\n     * The setter of the property.\n     * Default return behavior is 'sync'.\n     */\n    set?: FunctionDescriptor<'void' | 'sync'>;\n\n    /**\n     * If `true` then no setter will be generated for the proxy property.\n     * @default false\n     */\n    readonly?: boolean;\n}\n\n/**\n * Describes an argument for a function. If `idx` is not set then this\n * descriptor applies to *all* arguments.\n *\n * Since we only care about functions as arguments, for now, it is basically a FunctionDescriptor.\n * If the argument is not a function, do not specify a descriptor for it!\n */\nexport interface ArgumentDescriptor extends FunctionDescriptor {\n    idx?: number;\n}\n\n/**\n * Describes an object that we want to expose.\n */\nexport interface ObjectDescriptor {\n    type?: 'object';\n\n    /**\n     * List of functions we want to expose on the proxy object.\n     * Default return behavior is 'async'.\n     */\n    functions?: (string|FunctionDescriptor)[];\n\n    /**\n     * List of properties we want to expose on the proxy object.\n     */\n    proxiedProperties?: (string|PropertyDescriptor)[];\n\n    /**\n     * Since readonly property values don't change, they are sent to the other side, instead of generating a getter.\n     */\n    readonlyProperties?: string[];\n}\n\nexport interface ObjectDescriptorWithProps extends ObjectDescriptor {\n    /**\n     * This is filled in by the library. It contains the values of the readonlyProperties on the given object.\n     */\n    props?: any;\n}\n\n/**\n * Describes a class to expose.\n */\nexport interface ClassDescriptor {\n    type?: 'class';\n\n    /**\n     * Ignore this. Filled in by [[registerHostClass]] function.\n     */\n    classId?: string;\n\n    /**\n     * Expose a constructor function that will construct an instance on the host side.\n     * Default return behavior is 'sync'.\n     */\n    ctor?: FunctionDescriptor;\n\n    /**\n     * Describes the \"static\" part of the class, treated as an object.\n     */\n    static?: ObjectDescriptor;\n\n    /**\n     * Describes instances of this class.\n     */\n    instance?: ObjectDescriptor;\n}\n\nexport type Descriptor = ObjectDescriptor | FunctionDescriptor | PropertyDescriptor;\n\nexport type ObjectDescriptors = { [key: string]: ObjectDescriptorWithProps | FunctionDescriptor };\nexport type ClassDescriptors = { [key: string]: ClassDescriptor };\n\n// util functions\nexport function getPropName(descriptor: string | { name?: string }) {\n    return typeof descriptor === 'string' ? descriptor : descriptor.name || '';\n}\n\nexport function getArgumentDescriptor(descriptor: FunctionDescriptor, idx?: number) {\n    return typeof descriptor === 'object' ? descriptor.arguments?.find(arg => arg.idx == null || arg.idx === idx) : undefined;\n}\n\nexport function getFunctionDescriptor(descriptor: ObjectDescriptor, funcName: string) {\n    return <FunctionDescriptor>descriptor?.functions?.find(func => typeof func === 'object' && func.name === funcName);\n}\n\nexport function getPropertyDescriptor(descriptor?: ObjectDescriptor, propName?: string) {\n    return <PropertyDescriptor>descriptor?.proxiedProperties?.find(prop => typeof prop === 'object' && prop.name === propName);\n}\n\nexport function isFunctionDescriptor(descriptor?: Descriptor): descriptor is FunctionDescriptor {\n    return descriptor?.type === 'function';\n}","import { rpc_disposed, ProxyObjectRegistry } from './proxy-object-registry';\nimport {\n    ClassDescriptor, ClassDescriptors, Descriptor,\n    FunctionDescriptor, FunctionReturnBehavior,\n    getArgumentDescriptor, getFunctionDescriptor, getPropertyDescriptor, getPropName,\n    isFunctionDescriptor, ObjectDescriptor, ObjectDescriptors, ObjectDescriptorWithProps\n} from './rpc-descriptor-types';\nimport type {\n    RPC_AnyCallAction, RPC_AnyCallMessage,\n    RPC_AsyncCallAction, RPC_DescriptorsResultMessage,\n    RPC_Message, RPC_SyncCallAction, RPC_VoidCallAction\n} from './rpc-message-types';\n\n\ntype PromiseCallbacks = {\n    resolve: (data?: any) => void;\n    reject: (data?: any) => void;\n};\n\nexport type AnyConstructor = new (...args: any[]) => any;\nexport type AnyFunction = ((...args: any[]) => any);\n\ntype ClassRegistryEntry = {\n    descriptor: ClassDescriptor;\n    classCtor: AnyConstructor;\n};\n\ntype HostObjectRegistryEntry = {\n    target: any;\n    descriptor: FunctionDescriptor | ObjectDescriptor;\n};\n\n\nconst hostObjectId = Symbol('hostObjectId');\nconst proxyObjectId = Symbol('proxyObjectId');\nconst classIdSym = Symbol('classId');\n\n/**\n * The channel used for the communication.\n * Can support synchronous and/or asynchronous messages.\n *\n * Note: if sync/async is not supported, make sure to use the correct return type for functions: [[FunctionReturnBehavior]].\n */\nexport interface RPCChannel {\n    /**\n     * Sends a message and returns the response synchronously.\n     */\n    sendSync?: (message: RPC_Message) => any;\n\n    /**\n     * Sends a message asnychronously. The response will come via the `receive` callback function.\n     */\n    sendAsync?: (message: RPC_Message) => void;\n\n    /**\n     * Register a callback for when an async message arrives.\n     * Note: The \"context\" is exposed during function calls via the [[SuperRPC.currentContext]] property.\n     */\n    receive?: (callback: (message: RPC_Message, replyChannel?: RPCChannel, context?: any) => void) => void;\n}\n\n/**\n * The SuperRPC is the central piece. An instance must be created on both sides.\n *\n * Objects, functions or classes can be registered on the \"host\" side\n * (see [[registerHostObject]], [[registerHostClass]]) and then functions/properties can be\n * called from the \"client\" side (see [[getProxyObject]], [[getProxyClass]]).\n *\n * The RPC service is symmetric, so depending on the use-case (and the channel),\n * both side can be \"host\" and \"client\" at the same time.\n *\n * The constructor needs a function to generate unique IDs for objects.\n * In order to have no dependencies this needs to be passed in.\n * For convenience the examples use [nanoid](https://www.npmjs.com/package/nanoid).\n */\nexport class SuperRPC {\n    private channel!: RPCChannel;\n\n    private remoteObjectDescriptors?: ObjectDescriptors;\n    private remoteClassDescriptors?: ClassDescriptors;\n    private remoteDescriptorsCallbacks?: PromiseCallbacks;\n\n    private asyncCallbacks = new Map<number|string, PromiseCallbacks>();\n    private callId = 0;\n\n    private readonly proxyObjectRegistry = new ProxyObjectRegistry();\n    private readonly proxyClassRegistry = new Map<string, AnyConstructor>();\n    private readonly hostObjectRegistry = new Map<string, HostObjectRegistryEntry>();\n    private readonly hostClassRegistry = new Map<string, ClassRegistryEntry>();\n\n    /**\n     * @param objectIdGenerator A function to generate a unique ID for an object.\n     *\n     * When sending an object to the other side that can not be serialized, we\n     * generate an ID and send that instead. The other side creates a proxy object\n     * that represents the remote object.\n     */\n    constructor(private objectIdGenerator: () => string) {\n    }\n\n    /**\n     * Stores the current \"context\" object that is passed to the callback of the [[RPCChannel.receive]] function.\n     */\n    public currentContext: any;\n\n    /**\n     * Connect the service to a channel.\n     */\n    connect(channel: RPCChannel) {\n        this.channel = channel;\n        channel.receive?.(this.messageReceived.bind(this));\n    }\n\n    /**\n     * Register an object in the service to be called remotely.\n     * @param objId An ID that the \"client\" side uses to identify this object.\n     * @param target The target object\n     * @param descriptor Describes which functions/properties to expose\n     */\n    registerHostObject(objId: string, target: object, descriptor: ObjectDescriptor) {\n        descriptor.type = 'object';\n        (target as any)[hostObjectId] = objId;\n        this.hostObjectRegistry.set(objId, { target, descriptor });\n    }\n\n    /**\n     * Register a function in the service to be called remotely.\n     * @param objId An ID that the \"client\" side uses to identify this function.\n     * @param target The target function\n     * @param descriptor Describes arguments and return behavior ([[FunctionReturnBehavior]])\n     */\n    registerHostFunction(objId: string, target: AnyFunction, descriptor: FunctionDescriptor) {\n        descriptor.type = 'function';\n        (target as any)[hostObjectId] = objId;\n        this.hostObjectRegistry.set(objId, { target, descriptor });\n    }\n\n    /**\n     * Register a class in the service.\n     *\n     * When an instance of this class is passed to the other side, only the \"readonlyProperties\" are sent (see [[ClassDescriptor]]).\n     * Functions and proxied properties are generated there and those call back to the original object.\n     *\n     * Even the constructor can be proxied.\n     *\n     * Note: static functions/properties act as if the class was a normal host object.\n     *\n     * @param classId An ID to identify the class on the client side.\n     * @param classCtor The class itself (its constructor function)\n     * @param descriptor What properties/functions to expose\n     */\n    registerHostClass(classId: string, classCtor: AnyConstructor, descriptor: ClassDescriptor) {\n        descriptor.type = 'class';\n        descriptor.classId = classId;\n\n        if (descriptor.static) {\n            this.registerHostObject(classId, classCtor, descriptor.static);\n        }\n\n        if (descriptor.ctor) {\n            this.registerHostFunction(classId + '.ctor', <any>classCtor, descriptor.ctor);\n        }\n\n        (classCtor as any)[classIdSym] = classId;\n        this.hostClassRegistry.set(classId, { classCtor, descriptor });\n    }\n\n    /**\n     * Send a request to get the descriptors for the registered host objects from the other side.\n     * Uses synchronous communication if possible and returns `true`/`false` based on if the descriptors were received.\n     * If sync is not available, it uses async messaging and returns a Promise.\n     */\n    requestRemoteDescriptors() {\n        if (this.channel?.sendSync) {\n            const response = this.sendSync({ action: 'get_descriptors' }) as RPC_DescriptorsResultMessage;\n            return this.setRemoteDescriptors(response);\n        }\n\n        return new Promise<void>((resolve, reject) => {\n            this.sendAsync({ action: 'get_descriptors' });\n            this.remoteDescriptorsCallbacks = { resolve, reject };\n        });\n    }\n\n    private setRemoteDescriptors(response: RPC_DescriptorsResultMessage) {\n        if (typeof response === 'object' && response.objects && response.classes) {\n            this.remoteObjectDescriptors = response.objects;\n            this.remoteClassDescriptors = response.classes;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Send the descriptors for the registered host objects to the other side.\n     * If possible, the message is sent synchronously.\n     * This is a \"push\" style message, for \"pull\" see [[requestRemoteDescriptors]].\n     */\n    sendRemoteDescriptors(replyChannel = this.channel) {\n        this.sendSyncIfPossible({\n            action: 'descriptors',\n            objects: this.getLocalDescriptors(this.hostObjectRegistry),\n            classes: this.getLocalDescriptors(this.hostClassRegistry),\n        }, replyChannel);\n    }\n\n    private getLocalDescriptors<T extends HostObjectRegistryEntry|ClassRegistryEntry>(registry: Map<string, T>):\n        T extends HostObjectRegistryEntry ? ObjectDescriptors : ClassDescriptors\n    {\n        const descriptors: any = {};\n        for (const key of registry.keys()) {\n            // .get() could return undefined, but we know it will never do that, since we iterate over existing keys\n            // therefore it is safe to cast it to the entry types\n            const entry = <ClassRegistryEntry|HostObjectRegistryEntry>registry.get(key);\n\n            if (!entry.descriptor) continue;\n\n            const descr = descriptors[key] = { ...entry.descriptor };\n\n            if (entry.descriptor.type === 'object' && entry.descriptor.readonlyProperties) {\n                const props: any = {};\n                for (const prop of entry.descriptor.readonlyProperties) {\n                    props[prop] = (entry as HostObjectRegistryEntry).target[prop];\n                }\n                (descr as ObjectDescriptorWithProps).props = props;\n            }\n        }\n        return descriptors;\n    }\n\n    private sendSync(message: RPC_Message, channel = this.channel) {\n        this.addMarker(message);\n        return channel?.sendSync?.(message);\n    }\n\n    private sendAsync(message: RPC_Message, channel = this.channel) {\n        this.addMarker(message);\n        channel?.sendAsync?.(message);\n    }\n\n    private sendSyncIfPossible(message: RPC_Message, channel = this.channel) {\n        return channel?.sendSync ? this.sendSync(message, channel) : this.sendAsync(message, channel);\n    }\n\n    private sendAsyncIfPossible(message: RPC_Message, channel = this.channel) {\n        return channel?.sendAsync ? this.sendAsync(message, channel) : this.sendSync(message, channel);\n    }\n\n    private addMarker(message: RPC_Message) {\n        message.rpc_marker = 'srpc';\n    }\n\n    private checkMarker(message: RPC_Message) {\n        return typeof message === 'object' && message.rpc_marker === 'srpc';\n    }\n\n    private callTargetFunction(msg: RPC_AnyCallMessage, replyChannel = this.channel) {\n        const entry = this.hostObjectRegistry.get(msg.objId);\n        let result: any;\n        let success = true;\n        try {\n            if (!entry) throw new Error(`No object found with ID '${msg.objId}'`);\n            let scope: unknown = null;\n            let { descriptor, target } = entry;\n\n            switch (msg.action) {\n                case 'prop_get': {\n                    result = target[msg.prop];\n                    break;\n                }\n                case 'prop_set': {\n                    const descr = getPropertyDescriptor(descriptor as ObjectDescriptor, msg.prop);\n                    target[msg.prop] = this.processAfterSerialization(msg.args[0], replyChannel, descr?.get?.arguments?.[0]);\n                    break;\n                }\n                case 'method_call': {\n                    scope = target;\n                    descriptor = getFunctionDescriptor(descriptor as ObjectDescriptor, msg.prop);\n                    target = target[msg.prop];\n                    if (typeof target !== 'function') throw new Error(`Property ${msg.prop} is not a function on object ${msg.objId}`);\n                    // NO break here!\n                }\n                // eslint-disable-next-line no-fallthrough\n                case 'fn_call': {\n                    result = target.apply(scope, this.deserializeFunctionArgs(descriptor as FunctionDescriptor, msg.args, replyChannel));\n                    break;\n                }\n                case 'ctor_call': {\n                    result = new target(...this.deserializeFunctionArgs(descriptor as FunctionDescriptor, msg.args, replyChannel));\n                    break;\n                }\n            }\n\n            if (msg.callType === 'async') {\n                Promise.resolve(result)\n                    .then(value => result = this.processBeforeSerialization(value, replyChannel), err => { result = err?.toString?.(); success = false; })\n                    .then(() => this.sendAsync({ action: 'fn_reply', callType: 'async', success, result, callId: msg.callId }, replyChannel));\n            } else if (msg.callType === 'sync') {\n                result = this.processBeforeSerialization(result, replyChannel);\n            }\n        } catch (err: any) {\n            success = false;\n            result = err?.toString?.();\n        }\n        if (msg.callType === 'sync') {\n            this.sendSync({ action: 'fn_reply', callType: 'sync', success, result }, replyChannel);\n        } else if (msg.callType === 'async' && !success) {\n            this.sendAsync({ action: 'fn_reply', callType: 'async', success, result, callId: msg.callId }, replyChannel);\n        }\n    }\n\n    private messageReceived(message: RPC_Message, replyChannel = this.channel, context?: any) {\n        this.currentContext = context;\n\n        if (this.checkMarker(message)) {\n            switch (message.action) {\n                case 'get_descriptors': {\n                    this.sendRemoteDescriptors(replyChannel);\n                    break;\n                }\n                case 'descriptors': {\n                    const success = this.setRemoteDescriptors(message);\n                    this.remoteDescriptorsCallbacks?.[success ? 'resolve' : 'reject']();\n                    this.remoteDescriptorsCallbacks = undefined;\n                    break;\n                }\n                case 'prop_get':\n                case 'prop_set':\n                case 'ctor_call':\n                case 'fn_call':\n                case 'method_call': {\n                    this.callTargetFunction(message, replyChannel);\n                    break;\n                }\n                case 'obj_died': {\n                    this.hostObjectRegistry.delete(message.objId);\n                    break;\n                }\n                case 'fn_reply': {\n                    if (message.callType === 'async') {\n                        const result = this.processAfterSerialization(message.result, replyChannel);\n                        const callbacks = this.asyncCallbacks.get(message.callId);\n                        callbacks?.[message.success ? 'resolve' : 'reject'](result);\n                        this.asyncCallbacks.delete(message.callId);\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n\n    private serializeFunctionArgs(func: FunctionDescriptor, args: any[], replyChannel: RPCChannel) {\n        return args.map((arg, idx) => this.processBeforeSerialization(arg, replyChannel, getArgumentDescriptor(func, idx)));\n    }\n\n    private deserializeFunctionArgs(func: FunctionDescriptor, args: any[], replyChannel: RPCChannel) {\n        return args.map((arg, idx) => this.processAfterSerialization(arg, replyChannel, getArgumentDescriptor(func, idx)));\n    }\n\n    private createVoidProxyFunction(objId: string|null, func: FunctionDescriptor, action: RPC_VoidCallAction, replyChannel: RPCChannel) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const _this = this;\n        const fn = function (this: any, ...args: any[]) {\n            if ((fn as any)[rpc_disposed]) throw new Error('Remote function has been disposed');\n            _this.sendAsyncIfPossible({\n                action,\n                callType: 'void',\n                objId: objId ?? this[proxyObjectId],\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                prop: func.name!,\n                args: _this.serializeFunctionArgs(func, args, replyChannel)\n            }, replyChannel);\n        };\n        return fn;\n    }\n\n    private createSyncProxyFunction(objId: string|null, func: FunctionDescriptor, action: RPC_SyncCallAction, replyChannel: RPCChannel) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const _this = this;\n        const fn = function (this: any, ...args: any[]) {\n            if ((fn as any)[rpc_disposed]) throw new Error('Remote function has been disposed');\n            const response = _this.sendSync({\n                action,\n                callType: 'sync',\n                objId: objId ?? this[proxyObjectId],\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                prop: func.name!,\n                args: _this.serializeFunctionArgs(func, args, replyChannel)\n            }, replyChannel);\n\n            if (!response) throw new Error('No response received');\n            if (!_this.checkMarker(response)) throw new Error(`Invalid response ${JSON.stringify(response)}`);\n\n            if (!response.success) throw new Error(response.result);\n            return _this.processAfterSerialization(response.result, replyChannel);\n        };\n        return fn;\n    }\n\n    private createAsyncProxyFunction(objId: string|null, func: FunctionDescriptor, action: RPC_AsyncCallAction, replyChannel: RPCChannel) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const _this = this;\n        const fn = function (this: any, ...args: any[]) {\n            return new Promise((resolve, reject) => {\n                if ((fn as any)[rpc_disposed]) throw new Error('Remote function has been disposed');\n                _this.callId++;\n                _this.sendAsync({\n                    action,\n                    callType: 'async',\n                    objId: objId ?? this[proxyObjectId],\n                    callId: _this.callId,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    prop: func.name!,\n                    args: _this.serializeFunctionArgs(func, args, replyChannel)\n                }, replyChannel);\n                _this.asyncCallbacks.set(_this.callId, { resolve, reject });\n            });\n        };\n        return fn;\n    }\n\n    private createProxyFunction(\n        objId: string | null,\n        prop: string | FunctionDescriptor,\n        action: RPC_AnyCallAction,\n        defaultCallType: FunctionReturnBehavior = 'async',\n        replyChannel = this.channel): AnyFunction | AnyConstructor\n    {\n        const descriptor = (typeof prop === 'object') ? prop : { name: prop };\n        let callType = descriptor?.returns || defaultCallType;\n\n        if (callType === 'async' && !replyChannel.sendAsync) callType = 'sync';\n        if (callType === 'sync' && !replyChannel.sendSync) callType = 'async';\n\n        switch (callType) {\n            case 'void': return this.createVoidProxyFunction(objId, descriptor, <RPC_VoidCallAction>action, replyChannel);\n            case 'sync': return this.createSyncProxyFunction(objId, descriptor, <RPC_SyncCallAction>action, replyChannel);\n            default: return this.createAsyncProxyFunction(objId, descriptor, <RPC_AsyncCallAction>action, replyChannel);\n        }\n    }\n\n    /**\n     * Gets or creates a proxy object that represents a host object from the other side.\n     *\n     * This side must have the descriptor for the object.\n     * See [[sendRemoteDescriptors]], [[requestRemoteDescriptors]].\n     */\n    getProxyObject(objId: string) {\n        let obj: any = this.proxyObjectRegistry.get(objId);\n        if (obj) return obj;\n\n        const descriptor = this.remoteObjectDescriptors?.[objId];\n        if (!descriptor) {\n            throw new Error(`No object registered with ID '${objId}'`);\n        }\n\n        if (isFunctionDescriptor(descriptor)) {\n            obj = this.createProxyFunction(objId, descriptor, 'fn_call');\n        } else {\n            obj = this.createProxyObject(objId, descriptor);\n        }\n\n        this.proxyObjectRegistry.register(objId, obj);\n        return obj;\n    }\n\n    /**\n     * Gets or creates a proxy \"class\" that will serve multiple purposes.\n     * - Static functions/properties on the class are proxied the same way as on a regular \"host\" object\n     * - If specified the constructor actually constructs an instance of the registered host class on the other side\n     * and the returned instance will represent the remote instance, with the specified functions/properties working\n     * on its prototype as expected.\n     * - If an instance of the registered host class is being sent from the other side,\n     * an instance of this proxy class will be created and passed on this side.\n     */\n    getProxyClass(classId: string): AnyConstructor {\n        let clazz = this.proxyClassRegistry.get(classId);\n        if (clazz) return clazz;\n\n        const descriptor = this.remoteClassDescriptors?.[classId];\n        if (!descriptor) {\n            throw new Error(`No class registered with ID '${classId}'`);\n        }\n\n        clazz = <AnyConstructor>(descriptor.ctor ? this.createProxyFunction(classId + '.ctor', descriptor.ctor, 'ctor_call', 'sync')\n            : function () { throw new Error(`Constructor of class '${classId}' is not defined`); });\n\n        // create the proxy functions/properties on the prototype with no objId, so each function will look up \"proxyObjectId\" on \"this\"\n        // so the prototype will work with multiple instances\n        this.createProxyObject(null, descriptor.instance as ObjectDescriptorWithProps, clazz.prototype);\n\n        // add static functions/props\n        const staticDescr = descriptor.static as ObjectDescriptorWithProps ?? {};\n        const objDescr = this.remoteObjectDescriptors?.[classId];\n        if (!isFunctionDescriptor(objDescr)) {\n            staticDescr.props = objDescr?.props;\n        }\n        this.createProxyObject(classId, staticDescr, clazz);\n\n        this.proxyClassRegistry.set(classId, clazz);\n\n        return clazz;\n    }\n\n    private createProxyObject(objId: string|null, descriptor?: ObjectDescriptorWithProps, obj: any = {}) {\n        Object.assign(obj, descriptor?.props);\n\n        for (const prop of descriptor?.functions ?? []) {\n            obj[getPropName(prop)] = this.createProxyFunction(objId, prop, 'method_call');\n        }\n\n        const setterCallType = this.channel.sendSync ? 'sync' : 'void';\n\n        for (const prop of descriptor?.proxiedProperties ?? []) {\n            const descr = typeof prop === 'string' ? { name: prop } : prop;\n            Object.defineProperty(obj, descr.name, {\n                get: <AnyFunction>this.createProxyFunction(objId, { ...descr.get, name: descr.name }, 'prop_get', 'sync'),\n                set: descr.readonly ? undefined : <AnyFunction>this.createProxyFunction(objId, { ...descr.set, name: descr.name }, 'prop_set', setterCallType)\n            });\n        }\n\n        obj[proxyObjectId] = objId;\n\n        return obj;\n    }\n\n    private registerLocalObj(obj: any, descriptor: FunctionDescriptor | ObjectDescriptor) {\n        let objId = obj[hostObjectId];\n        if (!this.hostObjectRegistry.has(objId)) {\n            objId = this.objectIdGenerator();\n            this.hostObjectRegistry.set(objId, { target: obj, descriptor });\n            obj[hostObjectId] = objId;\n        }\n        return objId;\n    }\n\n    private processBeforeSerialization(obj: any, replyChannel: RPCChannel, descriptor?: Descriptor) {\n        if (obj?.[proxyObjectId]) {\n            return { _rpc_type: 'hostObject', objId: obj[proxyObjectId] };\n        }\n\n        switch (typeof obj) {\n            case 'object': {\n                if (!obj) break;\n\n                // special case for Promise\n                if (obj.constructor === Promise) {\n                    if (!this.hostObjectRegistry.has((obj as any)[hostObjectId])) {\n                        let result: unknown;\n                        let success: boolean;\n                        obj.then(\n                            (value) => { result = value; success = true; },\n                            (value) => { result = value; success = false; }\n                        ).finally(() => this.sendAsyncIfPossible({ action: 'fn_reply', callType: 'async', success, result, callId: objId }, replyChannel));\n                    }\n                    const objId = this.registerLocalObj(obj, {});\n                    return { _rpc_type: 'object', objId, classId: 'Promise' };\n                }\n\n                const entry = this.hostClassRegistry.get(obj.constructor?.[classIdSym]);\n                if (entry) {\n                    const objId = this.registerLocalObj(obj, entry.descriptor.instance ?? {});\n                    const props: any = {};\n\n                    for (const prop of entry.descriptor.instance?.readonlyProperties ?? []) {\n                        const propName = getPropName(prop);\n                        props[propName] = this.processBeforeSerialization(obj[propName], replyChannel);\n                    }\n\n                    return { _rpc_type: 'object', classId: entry.descriptor.classId, props, objId };\n                }\n\n                for (const key of Object.keys(obj)) {\n                    obj[key] = this.processBeforeSerialization(obj[key], replyChannel);\n                }\n                break;\n            }\n            case 'function': {\n                const objId = this.registerLocalObj(obj, descriptor as FunctionDescriptor);\n                return { _rpc_type: 'function', objId };\n            }\n        }\n        return obj;\n    }\n\n    private processAfterSerialization(obj: any, replyChannel: RPCChannel, descriptor?: Descriptor) {\n        if (typeof obj !== 'object' || !obj) return obj;\n\n        switch (obj._rpc_type) {\n            case 'object': {\n                return this.getOrCreateProxyInstance(obj.objId, obj.classId, obj.props, replyChannel);\n            }\n            case 'function': {\n                return this.getOrCreateProxyFunction(obj.objId, replyChannel, descriptor as FunctionDescriptor);\n            }\n            case 'hostObject': {\n                return this.hostObjectRegistry.get(obj.objId)?.target;\n            }\n        }\n\n        for (const key of Object.keys(obj)) {\n            obj[key] = this.processAfterSerialization(obj[key], replyChannel, getPropertyDescriptor(descriptor as ObjectDescriptor, key));\n        }\n\n        return obj;\n    }\n\n    private sendObjectDied(objId: string, replyChannel = this.channel) {\n        this.sendAsyncIfPossible({ action: 'obj_died', objId }, replyChannel);\n    }\n\n    private getOrCreateProxyInstance(objId: string, classId: string, props: any, replyChannel: RPCChannel) {\n        let obj = this.proxyObjectRegistry.get(objId);\n        if (obj) return obj;\n\n        obj = props ?? {};\n\n        // special case for Promise\n        if (classId === 'Promise') {\n            obj = new Promise((resolve, reject) => this.asyncCallbacks.set(objId, { resolve, reject }));\n        } else {\n            obj[proxyObjectId] = objId;\n            const clazz = this.getProxyClass(classId);\n            Object.setPrototypeOf(obj, clazz.prototype);\n        }\n\n        this.proxyObjectRegistry.register(objId, obj, () => this.sendObjectDied(objId, replyChannel));\n        return obj;\n    }\n\n    private getOrCreateProxyFunction(objId: string, replyChannel: RPCChannel, descriptor?: FunctionDescriptor) {\n        let fn = this.proxyObjectRegistry.get(objId);\n        if (fn) return fn;\n\n        if (descriptor) descriptor.type = 'function';\n        fn = this.createProxyFunction(objId, <any>descriptor, 'fn_call', 'async', replyChannel);\n        fn[proxyObjectId] = objId;\n        this.proxyObjectRegistry.register(objId, fn, () => this.sendObjectDied(objId, replyChannel));\n\n        return fn;\n    }\n\n}\n"],"names":[],"mappings":"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"}